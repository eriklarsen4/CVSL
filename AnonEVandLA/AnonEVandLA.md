Projecting EVs
================
Erik Larsen
3/31/2022

## Approach/Analysis

I was given a dataset with **7 columns**: `batter`, `pitcher`, `hittype`, `speed_A`, `vangle_A`, `speed_B`, `vangle_B`.
I was told that in this dataset, `Exit Velocities` (`speed_A` or `speed_B`) and `Launch Angles` (`vangle_A` or `vangle_B`) were recorded by two measurement systems for each batted ball event.

By the number of unique `batter`s and number of events, I figured that this data was over the course of one season. Each batted ball event was also described as belonging to one of a group of `hittype`s (`ground_ball`, `line_drive`, `fly_ball`, `popup`, or `unknown`).

My goal was to use either or both systems to predict/project `Exit Velocities` for each player for the following season based only on this dataset. I was given one "hint": one system was speculated to be better than another, and a strong component of the evaluation of my output was how I handled events where the systems failed to record metrics (`NA`s). I was also given a time constraint.

**General Approach**

-   I first skimmed the df to assess `NA` locations and did quick, broad-level
    stats on the distributions of non-`NA` events in both systems. Once
    I felt I understood the systems and then visualized the data, I
    could decide how to impute (replace) `NA`s and project `EV`s. Initially, **I
    intended to use multiple approaches** to impute `NA`s: to impute all
    `NA`s with median values by `hittype`, to impute by `regression`, and to impute
    by `k-Nearest Neighbors`, and compare the results. But even with
    cutting/pasting plots with pre-existing code, I realized I wouldn’t
    have time for even two strategies, **so I chose regression to impute
    NAs** and **linear regression for predicting EVs**. I did not get to
    inspect those projections by evaluating residuals, or by plotting
    the projections.

**Visualization**

-   Visualizing each system’s data was important because it showed me
    why there was a suspicion one system (`System A` is `Hawkeye`?) was 
    better than the other: `System B` contained “mis-tracked”
    data: `ground_ball`s with `LA`s &gt; 0 and `EV`s \~ &lt; 60. These events
    were manually/visually annotated, so I assumed these data were incorrectly
    tracked. `Ground_ball`s should have far smaller `launch angles`. This
    convinced me to remove "erroneous" data and return to it, if possible (time
    ran out). Interestingly, after doing this, I confirmed both
    `System A` and `System B` had fairly tightly linear values for `LA`.

    This enabled me to use linear regression and impute `NA` `vangle_A`s with not-missing `vangle_B`s, though the extreme ends would be slightly mis-calibrated.
    The relationship between `LA` and `EV` resembled something parabolic. And since `System A` was hinted at being more accurate, I figured to use a general additive model to predict `EV`s using `LA`s of `System A` for projections once I imputed missing values accounted for. I did not re-calibrate `System A` `ground_ball` `EV`s, but I should have.

**Imputing NAs**

-   To clarify, there were 3 cases of `NA` conditions:
    + batted ball events in `System A` **only** (not recorded in `A`)
    + in `System B` **only** (not recorded in `B`)
    + or in **both** (i.e. events `NA` by both tracking systems, but visually determined to be a ball in play).
-   Thus, my plan was to first impute the `NA`s occurring in **both**
    systems with the respective medians for `System B` variables:
    + where `NA`s were present in `speed_A`, `vangle_A`, `speed_B`, `vangle_B`, impute
    `speed_B` `NA`s with the median `speed_B` value; repeat for `vangle_B`.
-   This would account for as many missing data points as
    possible ahead of using regression to replace missing `System A` `NA`s
    when `System B`s were known, but shrink the variation of the true
    dataset to a small degree.

-   After the imputation of `System B` variables,
    I regressed `vangle_A` with `vangle_B` in a **generalized additive model**.
    I used the fit to make predictions for all `vangle_A`s where there was
    a `vangle_B` and imputed the `vangle_A` `NA`s with these predictions.

-   The `EV` was tricky: again, plotting `ground_ball` `EV`s showed some events
    had a linear relationship between `speed_A` and `speed_B`, and many
    events with a non-linear relationship. I fit one **GAM** for
    `speed_A` \~ `speed_B` for each `hittype` (4 separate **GAM**s) and
    imputed the `speed_A` `NA`s with the predictions of each
    `hittype`-specific model between systems.

**Projections**

-   With `speed_A` and `vangle_A` `NA`s accounted for, I fit a **GAM**
    to `speed_A` and `vangle_A`, where `speed_A` \~ `vangle_A`. I used
    predictions generated by this model as my projections for each event
    (still omitting all events where `ground_ball`s with
    `vangle_B`s &gt; 0 and `speed_B`s \~ &lt; 60; the majority of these
    were `NA` in `System A`). I averaged each hitter’s `EV` of the
    appropriate `hittype` and computed a weighted average of these
    predictions: for each hitter, I weighted the average of the
    predictions of a given `hittype` by the number of events of that
    type; I then averaged the sum. These were my projections. I did not account for random effects of any kind- hitter or pitcher.

## Environment Prep

``` r
library(readr)
library(tidyverse)
library(ggplot2)
library(ggpubr)
library(mgcv)
library(splines)
```

Set file path and import data

``` r
BATTED_BALL_DF =
  read.csv("https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/battedBallData.csv")

  ## Find indeces of NAs; by eye, looked sparse
for(i in 4:7) {
  print(length(which(is.na(BATTED_BALL_DF[,i]) == TRUE)))
}
```

    ## [1] 7572
    ## [1] 7572
    ## [1] 1402
    ## [1] 1402

``` r
  ## Find whether any of the NAs in speedA are also NA in vertAngA
speed_A_NA_idx = which(is.na(BATTED_BALL_DF$speed_A) == TRUE)
vangle_A_NA_idx = which(is.na(BATTED_BALL_DF$vangle_A) == TRUE)
speed_B_NA_idx = which(is.na(BATTED_BALL_DF$speed_B) == TRUE)
vangle_B_NA_idx = which(is.na(BATTED_BALL_DF$vangle_B) == TRUE)

#BATTED_BALL_DF[
#  na.omit(speed_B_NA_idx[match(speed_A_NA_idx, speed_B_NA_idx, nomatch = NA_integer_)]), ]
 
 ## Yes, sometimes, both systems missed events

  ## Any misses by on-field scouts?
#which(is.na(BATTED_BALL_DF$hittype) == TRUE) ## No (two "U" events)

  ## How much is missing from System A?
#length(which(is.na(BATTED_BALL_DF$speed_A) == TRUE))/nrow(BATTED_BALL_DF)*100 ## 10%

  ## How much is missing from System B?
#length(which(is.na(BATTED_BALL_DF$speed_B) == TRUE))/nrow(BATTED_BALL_DF)*100 ## 2%

  ## Check out the distributions of each system with NAs in one or the other
    ## for inference and plotting limits
BATTED_BALL_DF %>%
  group_by(hittype) %>%
  summarise(meanspeed_A = mean(speed_A, na.rm = T),
            meanspeed_B = mean(speed_B, na.rm = T),
            rspeed_A = range(speed_A, na.rm = T),
            rspeed_B = range(speed_B, na.rm = T),
            sdspeed_A = sd(speed_A, na.rm = T),
            sdspeed_B = sd(speed_B, na.rm = T),
            meanvangle_A = mean(vangle_A, na.rm = T),
            meanvangle_B = mean(vangle_B, na.rm = T),
            rvangle_A = range(vangle_A, na.rm = T),
            rvangle_B = range(vangle_B, na.rm = T),
            sdvangle_A = sd(vangle_A, na.rm = T),
            sdvangle_B = sd(vangle_B, na.rm = T)) %>%
  filter(hittype != "U")
```

    ## # A tibble: 8 x 13
    ## # Groups:   hittype [4]
    ##   hittype     meanspeed_A meanspeed_B rspeed_A rspeed_B sdspeed_A sdspeed_B
    ##   <chr>             <dbl>       <dbl>    <dbl>    <dbl>     <dbl>     <dbl>
    ## 1 fly_ball           90.1        86.3     50.8    49.5       9.31      9.09
    ## 2 fly_ball           90.1        86.3    115.    111.        9.31      9.09
    ## 3 ground_ball        86.1        68.2     26.5     5.15     14.6      20.9 
    ## 4 ground_ball        86.1        68.2    122.    114.       14.6      20.9 
    ## 5 line_drive         92.8        88.7     35.4    30.2      11.7      11.1 
    ## 6 line_drive         92.8        88.7    119.    114.       11.7      11.1 
    ## 7 popup              73.9        71.7     35.1    25.3      11.3      11.0 
    ## 8 popup              73.9        71.7    106.    105.       11.3      11.0 
    ## # ... with 6 more variables: meanvangle_A <dbl>, meanvangle_B <dbl>,
    ## #   rvangle_A <dbl>, rvangle_B <dbl>, sdvangle_A <dbl>, sdvangle_B <dbl>

``` r
  ## Trackman (B?) miss high speed low angle/grounders?
BATTED_BALL_DF %>%
  group_by(hittype) %>%
  summarise(sum(length(which(!is.na(speed_A)))),
            sum(length(which(!is.na(speed_B))))) 
```

    ## # A tibble: 5 x 3
    ##   hittype     `sum(length(which(!is.na(speed_A))))` `sum(length(which(!is.na(s~`
    ##   <chr>                                       <int>                        <int>
    ## 1 fly_ball                                    16446                        16486
    ## 2 ground_ball                                 28648                        32558
    ## 3 line_drive                                  17908                        18036
    ## 4 popup                                        2800                         4891
    ## 5 U                                               1                            2

More events are recorded by `System B`, possibly affecting the dist.s

## Visualize the raw data (no imputation)

``` r
  ## Visualize the data; by batter should reveal a mishmash blob
    ## Hit classification should be more revealing
SysA = ggplot(data = BATTED_BALL_DF, aes(x = vangle_A)) +
  geom_point(aes(y = speed_A, color = hittype)) +
  coord_cartesian(xlim = c(-92,90),
                  ylim = range(BATTED_BALL_DF$speed_A)) +
  theme_bw() +
  labs(title = "System A Batted Balls\nExit Velos vs Launch Angles",
       x = "System A Launch Angles",
       y = "System A Exit Velocities") +
  theme(plot.title = element_text(hjust = 0.5, size = 15),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 13))
SysA
```

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/SystemA%20and%20SystemB-1.png)<!-- -->

``` r
    ## Repeat for System B
SysB = ggplot(data = BATTED_BALL_DF, aes(x = vangle_B)) +
  geom_point(aes(y = speed_B, color = hittype)) +
  coord_cartesian(xlim = c(-92, 90),
                  ylim = range(BATTED_BALL_DF$speed_B, na.rm = T)) +
  theme_bw() +
  labs(title = "System B Batted Balls\nExit Velos vs Launch Angles",
       x = "System B Launch Angles",
       y = "System B Exit Velocities") +
  theme(plot.title = element_text(hjust = 0.5, size = 15),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 13))
SysB
```

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/SystemA%20and%20SystemB-2.png)<!-- -->

Remove the poorly-tracked data from `System B` (`ground_balls` with high
`LA`s and low `EV`s)

``` r
Bad_SYS_B = BATTED_BALL_DF[
  -which(BATTED_BALL_DF$speed_B < 60 & BATTED_BALL_DF$vangle_B > 0 & BATTED_BALL_DF$hittype == "ground_ball"), ]
```

## Find relationship between variables in both systems (is there one?)

``` r
  ## Examine the relationship between the two systems to use for imputing NAs
    ## LA
LAs_no_bad_GBs = ggplot(data = Bad_SYS_B,
  aes(x = vangle_B)) +
  geom_point(aes(y = vangle_A, color = hittype)) +
  coord_cartesian(xlim = c(-92, 90),
                  ylim = c(-92,90)) +
  theme_bw() +
  labs(title = "Launch Angles from System A vs\nLaunch Angles from System B",
       x = "System B Batted Ball Launch Angles",
       y = "System A Batted Ball Launch Angles") +
  theme(plot.title = element_text(hjust = 0.5, size = 15),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 13))

LAs_no_bad_GBs ## ~linear
```

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/LAs_no_bad_GBs-1.png)<!-- -->

Use linear regression to fit the \~linear relationship between `LA`s
within each `hittype`

``` r
LA_lm_A = lm(data = Bad_SYS_B, formula = vangle_A ~ vangle_B)
  ## Include linear model predictions in the df to plot the fit
Bad_SYS_B$LAlmApreds = 0
Bad_SYS_B$LAlmApreds = as.numeric(predict.lm(LA_lm_A, newdata = Bad_SYS_B))
  ## Compare with a gam that incorporates BB type and is a natural cubic
LAAgammy = gam(data = Bad_SYS_B, newdata = Bad_SYS_B, formula = vangle_A ~ s(vangle_B, k = 3, bs = "cr"))

Bad_SYS_B$LAAGAMpreds = 0
Bad_SYS_B$LAAGAMpreds = as.numeric(predict.gam(LAAgammy, newdata = Bad_SYS_B))

  ## Plot the fit
LAs_no_bad_GBs +
  geom_smooth(method = "lm",
              aes(y = Bad_SYS_B$LAlmApreds), color = "black", size = 1.5) +
  geom_smooth(method = "gam",
              aes(y = Bad_SYS_B$LAAGAMpreds), color = "navy", size = 1.5, linetype = "dashed")
```

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/LAs_no_bad_GBs_wFit-1.png)<!-- -->

What about `EV`?

``` r
    ## EV
EV_no_bad_GBs = ggplot(data = Bad_SYS_B, aes(x = speed_B, y = speed_A)) +
  geom_point(aes(color = hittype)) +
  coord_cartesian(xlim = c(5, 125),
                  ylim = c(5, 125)) +
  theme_bw() +
  labs(title = "Exit Velocities from System B vs\nExit Velocities from Sytem A",
       x = "System B Batted Ball Velocities",
       y = "System A Batted Ball Velocities") +
  theme(plot.title = element_text(hjust = 0.5, size = 15),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 13))

## GB EVs are tough to fit (sys A ~ sys B) because 
## of the wide variation and mix of model shapes (linear, nonlinear)

    ## EV in B predicting EV in A
evA_evBgammy = gam(data = Bad_SYS_B,
                   newdata = Bad_SYS_B, formula = speed_A ~ s(speed_B, k = 3, bs = "cr"))
  ## Plot the fit
EV_no_bad_GBs +
  geom_smooth(method = "gam",
              aes(y = as.numeric(predict.gam(evA_evBgammy, newdata = Bad_SYS_B))),
              color = "gray48", size = 2, linetype = "dashed")
```

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/EV_no_bad_GBs_wFit-1.png)<!-- -->

`speed_A` values are higher than `speed_B`. Based on the regression,
there are many high velocity `ground_ball`s in `System A` above the fit,
suggesting imputed `NA`s may drag values down. Since other hittypes are tightly linear, I suspect this is good, though not enough.

-   Impute medians of `Sys B` variables for events with `NA`s in both systems
-   Impute `Sys A` `vangle_A` `NA`s with predictions from a GAM/lm where `vangle_A` ~ `vangle_B`
-   Use individual `GAM`s by `hittype` to impute `speed_A` `NA`s
-   `GAM` fit to `GB` `speed_B`, `speed_A`
-   `GAM` fit to `LD` `speed_B`, `speed_A`, etc., etc.
-   With all `Sys A` values, build a `GAM` to `speed_A` \~ `vangle_A`,
    with `hittype` as factors
-   Predict each `EV` based on this `GAM`
-   Average the predictions for each hitter by `hittype`
-   **Weight the averages** by the corresponding **number of observations**
-   Average these averages (weighted average) for a predicted `EV`

## Calculate medians, impute events with NAs in both systems with medians

Re-fit `vangle_A`s from `vangle_B`s with imputed values

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/unnamed-chunk-5-1.png)<!-- -->

## Impute vangle\_As with predictions from separate GAMs (vangle\_As \~ vangle\_Bs)

## Impute NA speed\_As with predictions from a GAM fit by speed\_Bs; GAM for each BB type

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/unnamed-chunk-7-1.png)<!-- -->

![](https://github.com/eriklarsen4/Baseball/blob/thought-process-revision/AnonEVandLA/Figures/unnamed-chunk-8-1.png)<!-- -->

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/unnamed-chunk-9-1.png)<!-- -->

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/unnamed-chunk-10-1.png)<!-- -->

Impute

## Fit speed\_A to vangle\_A with a GAM and hittype as factors

For `EV` predictions

![](https://github.com/eriklarsen4/Baseball/blob/main/AnonEVandLA/Figures/GAM_speed_A_by_vangle_A_wHittype-1.png)<!-- -->

## Compute predicted exit velocities

    ## # A tibble: 812 x 2
    ##    batter wMean_projected_EVs
    ##     <int>               <dbl>
    ##  1      1                89.0
    ##  2      2                81.8
    ##  3      3                87.4
    ##  4      4                86.9
    ##  5      5                87.2
    ##  6      6                87.2
    ##  7      7                86.8
    ##  8      8                88.0
    ##  9      9                89.6
    ## 10     10                88.9
    ## # ... with 802 more rows

    ## [1] "mean"             "86.7918681454534"

    ## [1] "median"           "87.4408659371666"

    ## [1] "sd"               "4.04358523038245"

Compare the datasets before and after replacing `NA`s with regression
estimates.

    ## # A tibble: 8 x 13
    ## # Groups:   hittype [4]
    ##   hittype     meanspeed_A meanspeed_B rspeed_A rspeed_B sdspeed_A sdspeed_B
    ##   <chr>             <dbl>       <dbl>    <dbl>    <dbl>     <dbl>     <dbl>
    ## 1 fly_ball           90.1        86.3     50.8    49.5       9.31      9.09
    ## 2 fly_ball           90.1        86.3    115.    111.        9.31      9.09
    ## 3 ground_ball        86.1        68.2     26.5     5.15     14.6      20.9 
    ## 4 ground_ball        86.1        68.2    122.    114.       14.6      20.9 
    ## 5 line_drive         92.8        88.7     35.4    30.2      11.7      11.1 
    ## 6 line_drive         92.8        88.7    119.    114.       11.7      11.1 
    ## 7 popup              73.9        71.7     35.1    25.3      11.3      11.0 
    ## 8 popup              73.9        71.7    106.    105.       11.3      11.0 
    ## # ... with 6 more variables: meanvangle_A <dbl>, meanvangle_B <dbl>,
    ## #   rvangle_A <dbl>, rvangle_B <dbl>, sdvangle_A <dbl>, sdvangle_B <dbl>

    ## # A tibble: 8 x 13
    ## # Groups:   hittype [4]
    ##   hittype     meanspeed_A meanspeed_B rspeed_A rspeed_B sdspeed_A sdspeed_B
    ##   <chr>             <dbl>       <dbl>    <dbl>    <dbl>     <dbl>     <dbl>
    ## 1 fly_ball           90.1        86.3     50.8    49.5       9.31      9.09
    ## 2 fly_ball           90.1        86.3    115.    111.        9.31      9.09
    ## 3 ground_ball        85.5        69.7     26.5     5.15     14.3      19.9 
    ## 4 ground_ball        85.5        69.7    122.    114.       14.3      19.9 
    ## 5 line_drive         92.8        88.7     31.4    30.2      11.7      11.1 
    ## 6 line_drive         92.8        88.7    119.    114.       11.7      11.1 
    ## 7 popup              74.6        71.8     28.0    25.3      10.6      10.8 
    ## 8 popup              74.6        71.8    106.    105.       10.6      10.8 
    ## # ... with 6 more variables: meanvangle_A <dbl>, meanvangle_B <dbl>,
    ## #   rvangle_A <dbl>, rvangle_B <dbl>, sdvangle_A <dbl>, sdvangle_B <dbl>

## Conclusions/Interpretations

-   Out of time. I did not intend for my approach to be (what feels)
    redundant (repeated linear regressions with GAMs). 
    Other algorithms and workflows capable of more sensitive
    imputation (such as `k-Nearest Neighbors` off the top of my head)
    and estimation (simulations and sampling) may have been more useful
    with more time.
-   The maximum of my average projected `EV`s is \~**100mph**. I’m surprised
    at how high this number is (`Judge` had the highest of all qualified
    hitters last year (2021) at \~ **96mph**), though the 100mph max is likely
    due to only having one event. I was expected lower, particularly
    after imputing with `GAM`s that led to some more extreme values,
    instead of piling on additional weight to the median. This is
    supported by a comparison of the distribution of variables in the
    raw `BATTED_BALL_DF` with those of the `Bad_SYS_B`. The latter was
    slightly lower.
-   A bigger picture of these predictions, measuring spread, with
    **mean** = **86.8mph**, **median** = **87.4mph**, and **sd** =
    **4.0mph** seems plausible.
-   However, given that I omitted \~1400 `ground_balls` because they
    were mistracked in `System B`, a relatively high maximum predicted
    average isn’t too surprising. It is feasible, though would
    definitely need much refining, investigation, and analysis.
